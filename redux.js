//FLUX
//Это паттерн распространения данных в приложении
// Однонаправленный поток данных
// 1 Action объект js в котором должен быть указан type также может быть груз-payload
//Каждый action отправляется в каждый store 

//dispatcher получает action и перенаправляет его в каждое хранилище store
//Любое приложение FLUX имеет один диспатчер.
//Dispacher существует для направления трафика выступая в качестве центрального интерфейса между action and 

//Store это структуры, в которых хранятся состояния приложения 
//  state должeн быть изменен (или мутирован) в ответ на полученный action. Таким образом, stores не должны иметь сеттеры, а только геттеры.
// Важно понимать, что stores — это объекты, которые содержат как часть состояния приложения, так и средства изменения этого состояния в ответ на полученные действия (actions). Поскольку все stores получают все actions, store будет определять, следует ли изменять свое состояние при получении action, учитывая тип этого действия (action’s type). Если store имеет логику, связанную с этим типом, оно выполнит соответствующие actions, а затем отправит событие изменения во все views, которые были настроены для прослушивания изменений из этого store.

// Views — это то, что пользователь видит и с чем взаимодействует. Они являются интерфейсом для отображения данных из store, а также для отправки actions обратно в store через dispatcher

//         || Action           <=   /\
//         \/                       ||
//Action -> Dispatcher -> Store -> View

// REDUX
// Является ли Redux, строго говоря, реализацией Flux — вопрос некоторых дискуссий. Redux и Flux схожи в том, что они оба подчеркивают важность однонаправленного потока данных, и они оба корректируют состояние (state) посредством actions с полями type. 

//NO dispatcher ??
//One  Store С Redux все состояние вашего приложения находится в централизованном хранилище (store), которое служит единственным источником правды приложения.

// Редьюсеры — это чистые функции, которые принимают текущее состояние (state) и заданное действие (action) в качестве аргументов, и выводят либо не измененное состояние, либо новую копию состояния. Здесь важен термин «копия» — Redux считает состояние неизменным. Если необходимо изменить состояние, оно не изменяется напрямую. Вместо этого создается копия состояния, и редьюсер редактирует эту копию, затем возвращает ее, и заменяет исходное состояние его измененной копией.

//Reducer -> Store (subscribe) -> Component ->(dispatch) Action

// Thunk для асинхронщины