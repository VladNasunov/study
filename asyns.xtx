Event loop, stack micro macro

fetch
new HTMl http

event loop
queueMicrotask(func) добавляет функцию в очередь микротаск
функции обратного вызова для Observer API тоже добав в микротаски
Event loop у каждой вкладки свой и независимый
Также он есть у каждого окна фрейма и воркера
Есть возможность общения через механиз postMEssage, событие происходит без задержек 
Heap (куча) — объекты собраны в кучу, которая есть ни что иное, как название для наименее структурированной части памяти.
Stack (стопка, стек) — репрезентация единственного потока выполнения JavaScript-кода. Вызовы функций помещаются в стек (об этом ниже).
Browser or Web API’s (браузерные или веб API) — встроены в браузер и способны предоставлять данные из браузера и окружающей компьютерной среды и давать возможность выполнять с ними полезные и сложные вещи. Они не являются частью языка JavaScript, но они построены на его основе и предоставляют вам суперсилы, которые можно использовать в JavaScript коде.

function main() {
  console.log("A");
  setTimeout(function exec() {
    console.log("B");
  }, 0);
  runWhileLoopForNSeconds(3);
  console.log("C");
}
main();
function runWhileLoopForNSeconds(sec) {
  let start = Date.now(),
    now = start;
  while (now - start < sec * 1000) {
    now = Date.now();
  }
}
Output
A
C
B
сначала А -> затем тайм аут переходит в браузер api и начинается выполенине функции с циклом она занимает 3 секунды, все это время она забивает стек. После ее выполнения выполняется синх функция С и затем выходит B

var a = 5;
setTimeout(function timeout() {
  console.log("setTimeout", a);
  a = 10;
}, 10);
var p = new Promise(function (resolve, reject) {
  console.log("promise", a);
  a = 25;
  resolve();
});
p.then(function () {
  console.log("then", a);
});
console.log(a);

setTimeout(function timeout() {
  console.log("setTimeout");
}, 10);
var p = new Promise(function (resolve, reject) {
  console.log("promise");
  resolve();
});
p.then(function () {
  console.log("then");
});
setTimeout(function timeout() {
    console.log("setTimeout2");
  }, 0);
var a = new Promise(function (resolve, reject) {
  console.log("promise2");
  resolve();
});
a.then(function () {
  console.log("then2");
});
Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь.
Очередь, которую формируют такие задачи, называют «очередью макрозадач» (macrotask queue, термин v8)

Отметим две детали:

Рендеринг (отрисовка страницы) никогда не происходит во время выполнения задачи движком. Не имеет значения, сколь долго выполняется задача. Изменения в DOM отрисовываются только после того, как задача выполнена.
Если задача выполняется очень долго, то браузер не может выполнять другие задачи, обрабатывать пользовательские события, поэтому спустя некоторое время браузер предлагает «убить» долго выполняющуюся задачу. Такое возможно, когда в скрипте много сложных вычислений или ошибка, ведущая к бесконечному циклу.

Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микрозадачей. Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.

Также есть специальная функция queueMicrotask(func), которая помещает func в очередь микрозадач.
Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.

Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.

Более подробный алгоритм событийного цикла (хоть и упрощённый в сравнении со спецификацией):

Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).
Исполнить все микрозадачи:
Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
Отрисовать изменения страницы, если они есть.
Если очередь макрозадач пуста – подождать, пока появится макрозадача.
Перейти к шагу 1.v

Для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл, мы можем использовать Web Workers.
Это способ исполнить код в другом, параллельном потоке.
Web Workers могут обмениваться сообщениями с основным процессом, но они имеют свои переменные и свой событийный цикл.
Web Workers не имеют доступа к DOM, поэтому основное их применение – вычисления. Они позволяют задействовать несколько ядер процессора одновременно.

