// Encapsulation
// Abstraction
// Inheritance
// Polymorphism
// Dependency injection


//Инкапсуляция включает в себя идею о том что данные не могут быть доступны напрямую. Нужно вызывать методы вместо прямого доступа к данным
//Инкапсуляция позволят нам скрывать. показывать свойства функций

//Инкапсуляция препятствует прямому обращению к свойству или методу. А вместо этого, создаются посреднические свойства или методы, через которые и будет осуществляться доступ к оригиналам. Попытка обратится к инкапсулированным (скрытым) свойствам, вызовет ошибку. Инкапсулированные данные можно увидеть в коде, но к ним нельзя напрямую обратится и получить их. Другие программисты должны обращаться к некоторым данным только через разрешенные автором программы методы или функции. Такой подход в целом приносит только выгоду.

//Инкапсуляция с использованием замыканий
const createCounter = () => {
  let count = 0;
  return {
    click: () => count + 1,
    getCount: () => count.toLocaleString(),
  };
};
const counter = createCounter();
counter.click();
counter.click();
counter.click();
// console.log(counter.getCount());


// Функция User принимает два аргумента: name, age. Пример без инкапсуляции где мы можем добраться до свойств объекта 
function User(name, age) {
  // Создали два новых объекта и присвоили им свойства
  this.name = name;
  this.age = age;
  // Функция say будет выводить в консоль определенную информацию
  this.say = function () {
    console.log(`Имя пользователя: ${this.name}, Возраст: ${this.age}`);
  };
}
// Создадим нового пользователя
const misha = new User("Misha", 25);
// Получаем доступ к свойствам нового пользователя
// console.log(misha.name);
// console.log(misha.age);

// Функция User принимает два аргумента: name, age. Пример с инкапсуляцией
function User(name, age) {
  // Создали две переменных и присвоили им свойства
  let userName = name;
  let userAge = age;
  // Функция say будет выводить в консоль определенную информацию
  this.say = function () {
    console.log(`Имя пользователя: ${userName}, Возраст: ${userAge}`);
  };
}
// Создадим нового пользователя
const misha = new User("Misha", 25);
// Получаем доступ к свойствам нового пользователя
console.log(misha.userName);
console.log(misha.userAge);

misha.userName = "Oskar"; // меняем имя
misha.userAge = 32; // меняем возраст

// Метод say() покажет какие значения есть у объекта на данный момент.
misha.say();

//Абстракция это способ создания простой модели, которая содержит только важные свойства с точки зрения контекства приложения. Иными словами это способ скрыть от пользователя детали реализации и показать пользователям лишь функциональность.
//Мы не можем создать экземпляр абстрактного класса

//Все программмное обеспечение это абстракция, скрывающая всю тяжелую работу и бездумные детали
//Декомпозиция это процесс абстракции

//Полиморфизм
//Идея заключается в том чтобы вызывать один и тот же метод для разных объектов, и при этом каждый метод реагирует по своему
//Для этого полиморфизм использует наследование

//Это способность объекта в процессе своего выполнения ссылаться на экземпляры собственного класса или любого класса-потомка. Классы-потомки могут переопределять метод.
class Human {
  constructor(name) {
    this.name = name;
  }
  say() {
    return `hello my name is ${this.name} i like travelling`;
  }
}

class Man extends Human {
  constructor(name) {
    super(name);
  }
}
class Coder extends Human {
  constructor(name) {
    super(name);
  }
  say() {
    return `hello my name is ${this.name} i like coding`;
  }
}
const coder = new Coder("vlad");
const guy = new Human("guy");
console.log(coder.say());
console.log(guy.say());
