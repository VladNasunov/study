
This self используется для сохранения ссылки на исходный this даже при изменении контекста. Этот метод часто используется в обработчиках событий (особенно in closures).
* Обратите внимание, что использование this.self не рекомендуется, посколько window.self существует и может примести к ошибкам, если вы не будете осторожны.
* можно использоваить var that = this

* Функции объявленные внутри контекста (например обратные вызовы, замыкания), будут иметь доступ к переменным/функциям, объявленным в той же области видимости или выше.

* Использованна с new? Использует только что созданный объект
* Вызвана с помощью call, apply используем данный указанный объект
* Вызвана с объектом контекста, владеющего вызовом функции? Используем этот объект контекста.
*

В действительности this — это привязка, которая создается во время вызова функции, и на что она ссылается определяется тем, где и при каких условиях функция была вызвана.

Контекст выполнения — это абстрактное окружение, в котором вычисляется и выполняется JavaScript-код. Когда выполняется глобальный код, это происходит внутри глобального контекста выполнения. Код функции выполняется внутри контекста выполнения функции.

const { func } = require("prop-types");

Когда this используется внутри объекта, это ключевое слово ссылается на сам объект.

Применение this во вложенных объектах может создать некоторую путаницу. В подобных ситуациях стоит помнить о том, что ключевое слово this относиться к тому объекту, в методе которого оно используется.

При использовании функций, которые имеются в глобальном контексте (это отличает их от методов объектов) ключевое слово this в них будет указывать на объект window

Если сделать binding несколько контекстов

стрелочные функции имеют более короткую форму записи, чем функциональные выражения и не привязаны к собственным сущностям this, arguments, super или new.target. Стрелочные функции лучше всего подходят для использования их в роли обычных функций, а не методов объектов, их нельзя использовать в роли конструкторов.
Если происходит обращение к this, его значение берётся снаружи.
Стрелочные функции VS bind
Существует тонкая разница между стрелочной функцией => и обычной функцией, вызванной с .bind(this):
.bind(this) создаёт «связанную версию» функции.
Стрелка => ничего не привязывает. У функции просто нет this. При получении значения this – оно, как обычная переменная, берётся из внешнего лексического окружения.
Вкратце: контекст обычных функций зависит от места вызова, а контекст стрелочных функций — от того места, где они были определены.
Обычная функция ожидаемо связалась с контекстом того объекта, на котором она вызвана. А вот в случае стрелочной функции такого не произошло. Почему? Стрелочная функция не имеет своего контекста, она связывается с лексическим окружением, то есть функцией, внутри которой определена стрелочная функция. Это очень важный момент. Именно функция верхнего уровня задаёт контекст стрелочной функции, а не что-то другое. И это поведение нельзя изменить с помощью функций call или bind.

//Задачи
let obj222 = {
  foo: "bar",
  func: function () {
    var self = this;
    console.log("this.foo = " + this.foo); //bar
    console.log("self.foo = " + this.self); //undefined
    (function () {
      console.log("this.foo =" + this.foo); //undefined
      console.log("self.foo =" + this.self); //window
    })();
  },
};
obj222.func();

Написать свой bind
function fn(a, b) {
  console.log(a, b, this);
}
var magicFn = bind(fn, {});

magicFn(2, 3);

function bind(cb, context) {
  return function () {
    return cb.apply(context, arguments);
  };
}

При вызове функции с использованием ключевого слова new функция выступает в роли конструктора, и в данном случе this указывает на создаваемый объект.

При вызове new function
Создается новый объект он становится this
Неявно возвращается
Создается прототип

Если функция запускается как свойство объекта, то в this будет ссылка на этот объект. При этом не имеет значения, откуда данная функция появилась в объекте, главное — как она вызывается, а именно какой объект стоит перед вызовом функции:

var o = {
    f: function() {
        return this;
    }
}
var o2 = {f: o.f};
console.log(o.f() === o);//true
console.log(o2.f() === o2);//true

При простом вызове функции
var f = function () {
  // Функция f вызывается с помощью простого вызова - f(),
  // поэтому this ссылается на глобальный объект
  this.x = 5; // window.x = 5;

  // В пункте 1.1 также указано, что в самовызывающихся функциях this также ссылается на глобальный объект
  (function () {
    this.x = 3; // window.x = 3
  })();
  console.log(this.x); // console.log(window.x)
};
//При вызове obj = new f()
var f = function () {
  // Функция f вызывается с использованием ключевого слова new,
  // поэтому this ссылается на создаваемый объект (обозначим его как object)
  this.x = 5; // object.x = 5;

  // В пункте 1.1 также указано, что в самовызывающихся функциях this ссылается на глобальный объект
  (function () {
    this.x = 3; // window.x = 3
  })();
  console.log(this.x); // console.log(object.x)
};
//f.call(f)
var f = function () {
  // Функция f вызывается с помощью метода call
  // первым параметром в call указана сама функция (точнее объект) f, поэтому
  // поэтому this ссылается на f
  this.x = 5; // f.x = 5;

  // В пункте 1.1 также указано, что в самовызывающихся функциях this ссылается на глобальный объект
  (function () {
    this.x = 3; // window.x = 3
  })();
  console.log(this.x); // console.log(f.x)
};
obj.m.call(f);
var obj = {
  x: 4,
  m: function () {
    // функция вызвана с помощью метода call
    // первым аргументом указана функция f
    // поэтому this вновь ссылается на f
    // в предыдущем примере f.x было присвоено значение 5, поэтому результат 5
    console.log(this.x); // console.log(f.x)
  },
};

var obj1 = {
  hello: function () {
    console.log("Hello world");
    return this;
  },
  obj2: {
    breed: "dog",
    speak: function () {
      console.log("woof!");
      return this;
    },
  },
};

console.log(obj1);
console.log(obj1.hello()); // выводит 'Hello world' и возвращает obj1
console.log(obj1.obj2);
console.log(obj1.obj2.speak()); // выводит 'woof!' и возвращает obj2

function car(){
this.type = 'truck',
getCar(){
 console.log(this.type)
 }
}
setTimeout(()=> car.getCar, 1000)

var a = 3;

function foo() {
  this.a = 0;
}
var obj = {
  a: 3,
  foo: foo,
};
var bar = obj.foo;
bar();
console.log(a, obj.a);

Задачи

1 Что такое конекст исполнения и ключевое слово this

2 На что this указывает

Задача узнать чему равен this

var name = "Ivan";

var obj = {
  name: "Sergei",
  prop: {
    name: "Anna",
    getName: function () {
      return this.name;
    },
    getNameArrow: () => this.name,
    getNameIife: function () {
      return (function () {
        return this.name;
      })();
    },
  },
};

console.log(obj.prop.getName());
console.log(obj.prop.getNameArrow());
console.log(obj.prop.getNameIife());

var foo = function () {
  return this.name;
};
console.log(foo());
console.log(foo.call(obj.prop));
console.log(foo.apply(obj));
console.log(foo.bind(obj));

//Задача на потерю контекста
let user = {
  firstName: "Вася",
  sayHi() {
    console.log(`Привет, ${this.firstName}!`);
  },
};
setTimeout(user.sayHi, 1000);

..Решение 1: сделать функцию-обёртку
setTimeout(function() {
    user.sayHi(); // Привет, Вася!
  }, 1000);

// Решение 2: привязать контекст с помощью bind

let sayHi = user.sayHi.bind(user); // (*)
sayHi(); // Привет, Вася!
setTimeout(sayHi, 900); // Привет, Вася!

var name1 = "name5";
function arr0() {
  let name1 = "name4";
  function arr1() {
    const name1 = "name3";
    function arr2() {
      const name1 = "name";
      const arr = () => console.log(this.name1);
      arr();
    }
    arr2();
  }
  arr1();
}
arr0();
const arrow = {
  name1: "name",
  func: {
    name1: "name1",
    arr: () => console.log(this.name1),
  },
};

// console.log(ex.arrow.func.arr());
