Область видимости — это набор правил, которые определяют где и как переменная (идентификатор) могут быть найдены. Этот поиск может осуществляться для целей присваивания значения переменной, которая является LHS (left-hand-side) ссылкой, или может осуществляться для целей извлечения ее значения, которое является RHS (right-hand-side) ссылкой.

LHS-ссылки являются результатом операции присваивания. Присваивания, связанные с Областью видимости, могут происходить либо с помощью операции =, либо передачей аргументов (присваиванием) параметрам функции.

JavaScript Движок перед выполнением сначала компилирует код, и пока он это делает, он разбивает операторы, подобные var a = 2; на два отдельных шага:

Первый, var a, чтобы объявить ее в Область видимости. Это выполняется в самом начале, до исполнения кода.

Позже, a = 2 ищет переменную (LHS-ссылку) и присваивает ей значение, если находит.

Оба поиска ссылок LHS и RHS начинаются в текущей выполняющейся Области видимости и если нужно (т.е. они не нашли что искали в ней), они работают с их более высокими вложенными Областями видимости, с одной областью (этажом) за раз, ища идентификатор, пока не доберутся до глобальной (верхний этаж) и не остановятся, вне зависимости от результата поиска.

Невыполненные RHS-ссылки приводят к выбросу ReferenceError. Невыполненные LHS-ссылки приводят к автоматической, неявно созданной переменной с таким именем (если не включен "Строгий режим"), либо к ReferenceError (если включен "Строгий режим").


* У функции bar() есть доступ в лексической области видимости к внутренней области видимости foo(). Но в то же время, мы берем bar(), саму функцию, и передаем ее как значение. В этом случае мы возвращаем сам объект функции, на который ссылается bar.

После выполнения foo() мы присвоим значение, которая она возвращает (нашу внутреннюю функцию bar()) в переменную baz, а затем мы фактически вызовем baz(), который конечно вызовет нашу внутреннюю функцию bar(), просто с помощью другой ссылки в идентификаторе.

Естественно bar() выполнится. Но в этом случае, она выполняется снаружи относительно своей объявленной лексической области видимости.

После выполнения foo(), обычно мы ожидаем, что вся внутренняя область видимости foo() целиком будет удалена, поскольку мы знаем что Движок использует сборщик мусора, который исследует и освобождает память, которая больше не используется. Поскольку видно, что содержимое foo() больше не используется, кажется естественным, что оно должно быть удалено сборщиком.

Но "магия" замыканий не даст этому произойти. Эта внутренняя область видимости на самом деле все еще "используется", а потому не будет удалена. Кто ее использует? Сама функция bar().

Благодаря тому, где она была объявлена, у bar() есть замыкание лексической области видимости на внутренную область видимости foo(), которая удерживает область видимости для bar(), чтобы ссылаться на нее позднее.

bar() все еще содержит ссылку на эту область видимости и эта ссылка называется замыканием.

function foo() {
  let a = 2;

  function bar() {
    console.log(a);
  }

  return bar;
}

let baz = foo();

baz(); // 2 -- Ого, замыкание только что было раскрыто, мужики