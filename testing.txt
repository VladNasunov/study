//Компонентное\Модульное тестирование
Пишет разработчик на каждый модуль системы
Типа Корзина, Страница оплаты каждое обособленно

//Интеграционное тестирование 
Первая подтема
Тестирование интеграции компонентов
тестрование системы состоящие из 2 и более модулей
Например как мы можем со страницы корзины произвести оплату через платежную систему

ВТорая подтема Системное интеграционное тестрование
3 вида интерфейсов 
1 API
2 CLI (интерфей коммандной строки)
3 GUI (graphical user interface)

Системное тестирование 
Проход по бизнес флоу всего приложения
Проходит по всему приложению 

Приемочное тестирование 
Определение готовности продукта и достигается (через тестовые сценарии, на основе спеки и требований к продукту)
Это финальный этап продукта перед релизом 

UAT user acceptance testing (Пользовательское Приемочное тестирование)
Проводится пользователями конечного продукта 
Собирается группа пользователей 

Эксплутационное тестирование 
Тестируется либо пользователями либо администратором в среде имитирущее реальное окружение 
на этом этапе проверяется тестирование резервного копирования либо аварийного восттановления и безопасноить 

Тестирование на соответсвие контракту 
допустим требования к защите пользовательских Первая

Alpha 
Это Эксплутационное тестирование которое проводится на стороне разработчиков но не рамках нашей компаннии

Beta
Проводится на внешней стороне без участия разрабов 


Тестирование по позитивности
Позитивное 
применяется сценарии соответсветсвующие нормальному поведению системы

Негативное
применяется сценарии внештатного поведения системы
неверные данные или опр ситуации

Перевернутая пирамида тестирования или "Рожок мороженного"

Перевернутая пирамида считается не рекомендованной, хотя в практике такой подход встречается.

Основные тезисы: 
1. Тесты пользовательского интерфейса должны автоматизироваться в большей мере.
2. Длинные тестовые прогоны. Время выполнения занимает намного больше времени, чем другие типы тестов, потому что оно основано на взаимодействии с визуальными элементами пользовательского интерфейса и не обязательно имеет хуки в исходном коде;
3. Сложно поддерживать, так как тесты пользовательского интерфейса сложно писать и они очень сильно зависят даже от малейших изменений;
4. Больше подходит для сценариев позитивного пути. Тестирование отрицательных путей в сквозных тестах очень затратно и долго выполняется по сравнению с тестами более низкого уровня;
5. Ожидание написания модульных тестов до тех пор, пока функции не будут завершены, может привести к тому, что каждому придется несколько раз выполнить большую работу для решения проблемы.