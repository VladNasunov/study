//Shadow dom

// Доступность 
// Воможность использования интерфейса всеми вне зависимости от физических или технических ограничений
// Для пользователей
// с нарушениями зрения 
// с нарушением опорно-двигательного аппарата сложность ввода
// 10% людей с инвалидностью

// Браилевые клавиатуры для чтения 
// Скринридеры (прочитывают пользователю информацию) самый распространенный способ потреблять информацию 

// Изображения
// Добавлять атрибут alt чтобы пользователи слепые могли понять опичание картинки

// Для чекбоксов и радио добавлять поля label 
// Использовать тип данных для инпутов email, text, password, etc
// обязательные поля помечать require
// группируйте связанные поля с помощью fieldset и подписывать тегом legend

// Верстка 
// Указывать title spa при навигации меняется содержимое title
// Указывать язык страницы и отдельных элементов 
// Семантика соблюдение (использование html тегов по их смыслу)
// Заголовок может визуально отсутсвовать

// Пример 

<nav>
    <ul>
        {/* <li><a ссылка и тд/></li> */}
        <li></li>
        <li></li>
    </ul>
</nav>

// отдавать предпочтение встроенным html тегам
// Пример если это кнопка то должна быть <button> and not <div>стилизованный под кнопку

* <meta> определяет метатеги, которые используются для хранения информации предназначенной для браузеров и поисковых систем. Например, механизмы поисковых систем обращаются к метатегам для получения описания сайта, ключевых слов и других данных. Разрешается использовать более чем один метатег, все они размещаются в контейнере <head>. Как правило, атрибуты любого метатега сводятся к парам «имя=значение», которые определяются ключевыми словами content, name или http-equiv.

* Атрибут charset
Содержание
Указывает кодировку документа. Атрибут введён в HTML5 и предназначен для сокращения формы <meta>, которая задавала кодировку в предыдущих версиях HTML и XHTML.

* Метатег X-UA-Compatible позволяет веб-авторам выбирать, в какой версии Internet Explorer должна отображаться страница. IE11 внес изменения в эти режимы; см. Примечание IE11 ниже. Microsoft Edge , браузер, заменивший IE11, соблюдает мета-тег X-UA-Compatible только при определенных обстоятельствах. См.Примечание Microsoft Edge ниже.

* Элемент <meta> viewport дает браузеру инструкции о том, как управлять размером и масштабированием страниц.
content="width=device-width" устанавливает ширину страницы в соответствии с шириной экрана устройства или окна просмотра, которая будет варьироваться в зависимости от устройства.

<!Doctype hmtl>
<head>
<meta charset="UTF-8">
<meta http-qeuiv="x a Compatible content='IE=Edge"
<meta name="viewport" content="width=device-width, initial-scale=1.0"
<link rel="stylesheet" href=".././/"
<title>Helo</title>
</head>
<body>
<script src="./index.js"/>
</body>
</html>

<style>
h1{
    color: #fff;
}
</style>

*inline

Теневой DOM («Shadow DOM») используется для инкапсуляции. Благодаря ему в компоненте есть собственное «теневое» DOM-дерево, к которому нельзя просто так обратиться из главного документа, у него могут быть изолированные CSS-правила и т.д.
input::-webkit-slider-runnable-track {
  background: red;
}


* Каждый DOM-элемент может иметь 2 типа поддеревьев DOM:
Light tree – обычное, «светлое», DOM-поддерево, состоящее из HTML-потомков. Все поддеревья, о которых мы говорили в предыдущих главах, были «light».
Shadow tree – скрытое, «теневое», DOM-поддерево, не отражённое в HTML, скрытое от посторонних глаз

Элементы теневого DOM:
Обладают собственной областью видимости идентификаторов
Невидимы JavaScript селекторам из главного документа, таким как querySelector,
Стилизуются своими стилями из теневого дерева, не из главного документа

* Псевдокласс — это селектор, который выбирает элементы, находящиеся в специфическом состоянии, например, они являются первым элементом своего типа, или на них наведён указатель мыши. 
::hover, focus, last-child, only-child

* Псевдоэлементы ведут себя сходным образом, однако они действуют так, как если бы вы добавили в разметку целый новый HTML-элемент, а не применили класс к существующим элементам. Псевдоэлементы начинаются с двойного двоеточия :: before after


//Как брузер рендерит страницу
// 1 Начало разбора HTML
//Когда браузер получает HTML Из сети он начинает парсить (запускает статический анализатор Parser)его и создавать DOM
//Первый шаг разбиение HTML на токены, которые представляют начальные теги (start tags) and(end tags) и содержимое (content) из этого он строит DOM
//2 Получение внешних ресурсов (CSS, js)
//когда парсер встречает CSS блокирует рендеринг до тех пор пока не будет загружен полностью
//JS файлы по умолчанию также блокируют рендеринг но у них есть 2 атрибута
//async означает что файл будет выполнен как только он загрузится. это может быть как до так и после синтаксического анализа. ПО этому порядок выполнения не может быть гарантирован
//defer означает что выполнение файла будет отложено до завершения синтаксического анализа документы

//Чтобы пометить ресурс как важный и, следовательно, с большей вероятностью он должен быть загруженным на ранней стадии процесса рендеринга, можно использовать тег ссылки с rel = «preload». Это полезно, когда ресурс понадобится через несколько секунд после загрузки страницы — и вы хотите ускорить процесс.

{
    /* <link rel= "prefetch"> просит браузер загрузить и кэшировать ресурс (например, скрипт или таблицу стилей) в фоновом режиме. Загрузка происходит с низким приоритетом, поэтому не мешает более важным ресурсам. Это полезно, если ресурс понадобится на следующей странице, а вы хотите заранее его кэшировать.
  
  Здесь тоже браузер ничего не делает с ресурсом после загрузки. Скрипты не выполняются, таблицы стилей не применяются. Ресурс просто кэшируется и немедленно предоставляется по запросу. */
  }
  
  {
    /* <link rel= "preconnect"> просит браузер заранее подключиться к домену, когда вы хотите ускорить установку соединения в будущем. */
  }
  
  {
    /* <link rel= "prerender"> просит браузер загрузить URL-адрес и отобразить его на невидимой вкладке. Когда пользователь нажимает на ссылку, страница должна отобразиться немедленно. Это полезно, если вы уверены, что пользователь посетит определённую страницу, и хотите ускорить её отображение. */
  }
  
  //РЕзюме
  {
    /* <link rel= "preload"> — когда вам понадобится ресурс через несколько секунд
  <link rel= "prefetch"> — когда понадобится ресурс на следующей странице
  <link rel= "preconnect"> — когда вы знаете, что вам скоро понадобится ресурс, но вы ещё не знаете его полный URL
  <link rel= "dns-prefetch"> — аналогично, когда вы знаете, что вам скоро понадобится ресурс, но вы ещё не знаете его полный URL (для старых браузеров)
  <link rel= "prerender"> — когда вы уверены, что пользователи перейдут на определённую страницу, и хотите ускорить её отображение */
  }
  
  //CSSOM карта всех селекторов css и соотв свойств для каждого селектора
  //CSSOM очень похож на dom оба являются частью рендеринга. Они оба используются для построения дерева рендеринга, которое исп браузером
  //отличие CSSOM OT DOM ЧТО Он не может быть построен постепенно, поскольку правила css могут перезаписываь друг друга в разных точках !!!!Вот почему загрузка CSS блокирует рендеринг
  
  //После того как js and DOM будут полностью проанализированны и готовы,будет сгенерированно событие document.DOMContentLoaded
  // . Для любых сценариев, которым требуется доступ к DOM, например, для управления им или прослушивания событий взаимодействия с пользователем, рекомендуется сначала дождаться этого события перед выполнением сценариев.
  // document.addEventListener("DOMContentLoaded", (event) => {
  //   // You can now safely access the DOM
  // });
  
  // Объединение DOM и CSSOM, для построения дерево рендеринга
  // Дерево рендеринга представляет собой комбинацию DOM и CSSOM и представляет все, что будет отображаться на странице. Это не обязательно означает, что все узлы в дереве рендеринга будут визуально присутствовать, например узлы со стилями opacity: 0 или visibility: hidden будут включены и могут быть прочитаны программой чтения с экрана и т. д., тогда как те, которые настроены на display: none будет исключены. Кроме того, такие теги, как <head>, не содержащие визуальной информации, всегда будут пропущены.
  
* Вес селекторов
style=""     1,0,0,0
#id          0,1,0,0
.class       0,0,1,0
[attr=value] 0,0,1,0
LI           0,0,0,1
*            0,0,0,0

LI 0,0,0,1 — селектор по тегу

UL LI 0,0,0,2 — селектор c двумя тегами весит больше, чем с одним.

.orange 0,0,1,0 — селектор с классом весит больше, чем селектор с тегом.

.orange A SPAN 0,0,1,2 — селектор перевесит предыдущий, потому что помимо класса содержит два тега.

#page .orange 0,1,1,0 — селектор с ID перевесит всё, кроме inline-стилей.

Теперь сравним селекторы из исходного примера:

#container A0,1,0,1

.list A0,0,1,1

* Grid 
задать размеры строк и столбцов, используя свойства grid-template-rows и grid-template-columns
поместить дочерние элементы в сетку при помощи свойств grid-row и grid-column

* Для этого нужно вызвать метод event.stopPropagation().
* event.stopImmediatePropagation() не даст сработать обработчикам на соседнем объекте