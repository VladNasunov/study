Functions (create, invoke, arrow functions, rest/spread operator, default parameters, scope, closure, recursion)
Как рекурсия влияет не стек вызова
Повторить замыкания

Pure functions
Чистые функции = они всегда возвращают при передаче один и тех же аргументов один и тот же результат (Детерминированность)
Не обладают побочными эффектами
Побочные эффекты
Не оказывают воздействия на внешние по отношению к ней программы
Чисты функции стабильны, единообразны и предсказуемы (легко тестируемы)

Immutability
С течением времени не меняются
Если иммутНеизменность заключается не в изменении состояния, а в копировании старого состояния, изменении новой копии и замене старого состояния новым.
Неизменяемые объекты проще создавать, тестировать и использовать. Действительно, неизменяемые объекты всегда потокобезопасны. Они помогают избежать временной связи.
Временная связь - это связь, которая возникает, когда есть два или более члена класса, которые должны быть вызваны в определенном порядке. Использование неизменяемых объектов происходит без побочных эффектов.
Постоянная структура данных - это структура данных, которая всегда сохраняет свою предыдущую версию при её изменении. Такие структуры данных фактически неизменяемы, так как их операции не обновляют (заметно) структуру на месте, а вместо этого, всегда дают новую обновленную структуру.абельный объект пытаться изменить, сделать этого не удасться. Не должны менять входящие объекты

ССылочная прозрачность
При вводе одних и тех же данных, получаем один и тот же результат

Functions as first-class entities
Ссылки на функции можно хранить в константах и переменных и через них обращаться к фкнциям (ведут себя как переменные их можно присваивать, передавать и возвращать)
Фукнции можно передавать другим функциям в качестве параметров
Фунции можно возвращать из других функций

Functions composition
Композиция - создание сложной функциональности за счет объединения более простых функций.
const compose =
  (...fns) =>
  (x) =>
    fns.reduceRight((acc, fn) => fn(acc), x);

High order functions
Фунция принимает другую в качестве аргументов
Фунция возвращает другую в качестве результата своей работы
map, filter, reduce, promise, setTimeout

Предикат - функция которая возвращает логическое значение 

Recursion

Currying/Memoization
Карринг (curry) - преобразует функцию с несколькими аргументами в серию функций, каждая из которых принимает один аргумент
function multiply(a, b, c) {
  return a * b * c;
}

function multiply(a) {
  return (b) => {
    return (c) => {
      return a * b * c;
    };
  };
}
console.log(multiply(1)(2)(3)); // 6

Частичное применение (partial application) похоже на карринг - это процесс создания функции с меньшим количеством параметров.
Также, частичное применение - это применение к функции некоторых аргументов и возврат новой функции, в ожидании остальных аргументов. Примененные аргументы хранятся в замыкании (closure) и остаются доступными для любых из возвращенных функций в будущем, которые частично применены.

Мемозация это сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизаций, применяемый для увеличения скорости выполнения программ

Идея мемоизации это 2 концепта 1) замыканий 2) функции высшего порядка (которые возвр др функции)

Обычная фунция которая добавляет 10 к параметру
const add = (n) => n + 10;
add(9);

//Мемоизированная функция
const memoized = () => {
  let cache = {};
  console.log(cache);
  return (n) => {
    if (n in cache) {
      console.log("fetch from cache");
      return cache[n];
    } else {
      console.log("calc");
      let result = n + 10;
      cache[n] = result;
      return result;
    }
  };
};
// эту функцию возвратит memoized
const memo = memoized();
memo(10);
memo(1);
memo(10);
memo(10);
Memoized возвращает другую функцию которую мы можем вызварть тогда когда нужно, Такое возможно тк функции в js first class entities что позв исп их как функции высшего порядка
Переменная cache может хранить данные м/у вызовами фукнций тк она определена в замыкании
Мемоизированная функция это чистая функция

Мемоизированная функция вычисления фибоначи
Обычная функция фибоначи в рекурсией
function fibonaci(n) {
  if (n <= 1) {
    return 1;
  }
  return fibonaci(n - 1) + fibonaci(n - 2);
}
console.log(fibonaci(8));

function fibonaciMemo(n, memo) {
  memo = memo || {};
  if (memo[n]) {
    return memo[n];
  }
  if (n <= 1) {
    return 1;
  }
  return (memo[n] = fibonaciMemo(n - 1, memo) + fibonaciMemo(n - 2, memo));
}

// Императивный
const arr = [1, 2, null, 4, 5, undefined];

const imperative = [];
for (let i = 0, len = arr.length; i < len; i++) {
  if (arr[i]) {
    imperative.push(arr[i]);
  }
}

//Декларативный
const declarative = arr.filter(Boolean);

Пример декларативного языка
css, sql, 

Композиция
Композиция - создание сложной функциональности за счет объединения более простых функций. В некотором смысле, композиция - это вложение функций, каждая из которых передает свой результат в качестве входных данных для другой функции. Но вместо того, чтобы создавать неразборчивое количество вложений, мы создадим функцию более высокого порядка - compose(), которая принимает все функции, которые мы хотим объединить, и возвращает нам новую функцию для использования.

Композиция - это сердце и душа функционального программирования.
const upperCase = str => str.toUpperCase();
const exclaim = str => `${str}!`;
const repeat = str => `${str} `.repeat(3);

console.log(
  repeat(exclaim(upperCase("I love coding"))) // I LOVE CODING! I LOVE CODING! I LOVE CODING!
);
Первое, что мы хотим сделать со строкой, это возвести в верхний регистр, поэтому мы напишем функцию upperCase и передадим ей строку: «I love coding». Следующее - поставить восклицательный знак и повторить фразу 3 раза.

Например, мы создадим функцию compose, которая получит любое количество функций в качестве аргументов. Для этого мы будем использовать оператор rest.
Функция compose возвращает функцию, которая ожидает своего начального значения - назовем её x. Отсюда у нас есть массив функций fns. Важно обратить внимание на порядок, в котором мы хотим их вызвать: он идет справа налево. Сначала мы вызываем upperCase, exclaim, а потом repeat. Чтобы сделать это, мы используем reduceRight метод.

const upperCase = str => str.toUpperCase();
const exclaim = str => `${str}!`;
const repeat = str => `${str} `.repeat(3);

const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);

const withСompose = compose(
  repeat,
  exclaim,
  upperCase
);

console.log(withСompose("I love coding")); // I LOVE CODING! I LOVE CODING! I LOVE CODING!

Функция pipe, которая аналогична compose, но порядок аргументов обратный. pipe также принимает любое количество функций и начальное значение, но на этот раз вызывает reduce. Таким образом, чтобы сделать функцию withСompose с pipe, мы просто меняем порядок аргументов.

Давай создадим карри-функцию map, похожую на функцию map в Lodash. Сначала мы получим array, а затем callback и вернем array.map, передав ему callback. Хоть мы и можем передать функции withArr различные обратные вызовы, но мы заблокировали (ограничили) данные.

const map = array => cb => array.map(cb);

const arr = [1, 2, 3, 4, 5];
const double = n => n * 2;

const withArr = map(arr);

console.log(withArr(double)); // [ 2, 4, 6, 8, 10 ]
console.log(withArr(n => n * 3)); // [ 3, 6, 9, 12, 15 ]
