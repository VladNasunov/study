//SPA vs MPA
//ПЛюсы SPA
//Высокая скорость загрузки
// лёгкость создания. Для разработки SPA приложения уже готовы библиотеки и фреймворки, работа над frontend и backend может вестись параллельно. Кроме того, на основе готового кода в дальнейшем можно построить мобильное приложение;
// гибкость пользовательского интерфейса. Для одной страницы проще разработать увлекательный и интерактивный дизайн интерфейса;
// простое кэширование данных. Важные данные загружаются в один запрос, а далее пользователь одностраничного приложения может работать частично оффлайн, подключаясь к интернету, чтобы сохранить прогресс.

//Минусы SPA
// Кроме того, существует проблема утечки памяти JavaScript, которая уменьшает скорость загрузки и открывает ваши данные для действий злоумышленников.

// Кроме того, одностраничные приложения:
// плохо поддаются SEO оптимизации. URL страниц практически не меняется, а данные подгружаются динамически, когда для оптимизации важна устойчивость и уникальные URL для каждой страницы. Поисковым ботам сложно просканировать SPA приложение, и на данный момент грамотно индексировать такие сайты умеет только Google;
// сильно нагружают браузер. Такая проблема возникает из-за относительно “тяжёлых” клиентских фреймворков;
// могут недёшево стоить. Разумеется, итоговая стоимость разработки разнится, но цена сложных сайтов довольно высока.

//ПЛюсы MPA
// Простая SEO-оптимизация. MPA часто используют сайты, для которых важно попадать в топы поисковых систем. Каждая из страниц имеет уникальный URL и стабильна, что позволяет поисковым ботам адекватно ее просканировать.
// Масштабируемость. В MPA приложение можно вложить столько информации, сколько потребуется, без ограничений по страницам и функциям.
// Проверенная классика. MPA работают по тем же принципам, что и знакомые пользователю веб-сайты с классической навигацией.

//минусы
// Низкая скорость разработки. MPA приложения требуют использования фреймворков на обеих сторонах: клиента и сервера. Также из-за тесной взаимосвязи frontend и backend усложняется работа разработчиков. Всё это в совокупности увеличивает бюджет и сроки разработки.
// Затраты на создание мобильного приложения. MPA приложения плохо конвертируются в мобильные. Для этого в значительной части случаев потребуется разработка backend с ну

//Чтобы начать работу с PWA, пользователю необходимо скачать и установить сайт как приложение. Последующий доступ к сайту производится через иконку на рабочем столе пользователя
// PWA приложения интересны тем, что они:
// кроссплатформенны — работают сразу на нескольких операционных системах;
// устанавливаются в один клик, без переходов в маркеты приложений;
// всегда под рукой у пользователя — сайт доступен по иконке в смартфоне даже в оффлайн режиме;
// снижают конкуренцию в поисковых системах;
// позволяют отправлять push-уведомления, как приложение;
// легко конвертируемы из существующего сайта, достаточно немного его изменить.

//Всплытие погружение
// Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:
// Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков.
// Целевая фаза — это когда событие достигает целевого элемента.
// Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window.
// Если мы кликнем по элементу child, в консоль будет выведено: child, parent, grandparent, html, document, window
// У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения

//event.preventDefault() отключает поведение элемента по умолчанию
//event.stopPropagation() отключает распространение события (его всплытие или погружение).
// event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault.

const obj = {};
console.log(obj.someprop); //undefined
console.log(obj.someprop.x); //error cannot read property undefined

// «use strict» — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах.
//Нельзя присваивать значения или обращаться к необъявленным переменным, Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи:
function returnY() {
  "use strict";
  y = 123;
  return y;
}
returnY();

var NaN = NaN; // Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#<Window>'
var undefined = undefined;
var Infinity = "and beyond";

//Запрещено дублирование параметров:
//Нельзя создавать функции с помощью функции eval:
// /Значением «this» по умолчанию является undefined:

//DNS

//Boxing или упаковка когда примитив оборачивается в объект и через прототип вызываются методы например toString()
const foo = 1;
foo.toString();

const obj1 = {
  name: "nastya",
};
Object.defineProperties(obj1, "name", {
  writable: false,
});
console.log(obj1);
console.log(3);

