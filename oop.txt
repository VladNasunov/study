Encapsulation
Abstraction
Классическое наследование
То есть абстракция — это представление вещей реального мира в компьютерных программах.
Теоретически абстракция определяется как «общая концепция, сформированная путем извлечения общих черт из конкретных примеров». Именно ради этого объяснения мы будем использовать вышеупомянутое определение.
Объекты в классических объектно-ориентированных языках программирования могут быть созданы только путем создания экземпляров классов.
Следовательно, по мере увеличения уровня абстракции сущности становятся более общими, а по мере снижения уровня абстракции сущности становятся более конкретными. В этом смысле уровень абстракции аналогичен шкале, варьирующейся от более специфических сущностей до более общих сущностей
Задача программиста при использовании парадигмы классического наследования создать иерархию сущностей от максимальной общей к максимально конкретной.

Прототипированое наследование
При использование парадигмы прототипного наследования программист имеет дело только с объектами и при этом у него есть возможность создавать сущности в одном уровне абстракции.

Просто одни объекты созданы от других. Это важно! А при классическом наследование обобщения являются абстракциями абстракций… от абстракций … вплоть до самого последнего потомка.
Было бы правильнее в данном случае привести пример из независимых объектов, но для объяснения разницы думаю этого будет достаточно.
Уровень абстракции здесь не обязан быть глубже одного уровня (хотя при желание может и быть).

В заключении отвечая на вопрос чем отличается классическое наследование от прототипного, можно сказать, что при следовании парадигме классического наследования нам необходимо создавать иерархию классов от общему к частному создавая тем самым при каждом наследовании дополнительный уровень абстракции. При следовании парадигме прототипного наследования мы не обязаны создавать иерархию от общего к частному, мы можем это делать а можем и не делать. Это оставляет нам свободу выбора (независимо от того понимаем мы это или нет), что и является на мой взгляд главным отличием этих двух парадигм.

В конце каждой типичной цепочки [[Prototype]] находится встроенный объект Object.prototype. Этот объект содержит различные утилиты, используемые в JS повсеместно, поскольку все обычные (встроенные, не связанные с конкретной средой исполнения) объекты в JavaScript "происходят от" объекта Object.prototype (иными словами, имеют его на вершине своей цепочки [[Prototype]]).
Если стандартная операция [[Get]] не может найти запрашиваемое свойство в самом объекте, то она следует по ссылке [[Prototype]] этого объекта.

По аналогии с этим процессом поиска по цепочке [[Prototype]], если вы используете цикл for..in для итерации по объекту, будут перечислены все свойства, достижимые по его цепочке (при условии, что они перечислимые — см. enumerable в главе 3). Если вы используете оператор in для проверки существования свойства в объекте, то in проверит всю цепочку объекта (независимо от перечисляемости).
Вопрос как вывести все свойства объекта и его родителей
let parent = {
  people: true,
};
let object = Object.create(parent, {
  name: {
    value: 'vlad',
  },
});
let abotherobj = Object.create(object, {
  age: {
    value: 15,
  },
});
for(let key in abotherobj){
  console.log(key)
}
Inheritance
Polymorphism
Dependency injection

Инкапсуляция включает в себя идею о том что данные не могут быть доступны напрямую. Нужно вызывать методы вместо прямого доступа к данным
Инкапсуляция позволят нам скрывать. показывать свойства функций

Инкапсуляция препятствует прямому обращению к свойству или методу. А вместо этого, создаются посреднические свойства или методы, через которые и будет осуществляться доступ к оригиналам. Попытка обратится к инкапсулированным (скрытым) свойствам, вызовет ошибку. Инкапсулированные данные можно увидеть в коде, но к ним нельзя напрямую обратится и получить их. Другие программисты должны обращаться к некоторым данным только через разрешенные автором программы методы или функции. Такой подход в целом приносит только выгоду.

Инкапсуляция с использованием замыканий
const createCounter = () => {
  let count = 0;
  return {
    click: () => count + 1,
    getCount: () => count.toLocaleString(),
  };
};
const counter = createCounter();
counter.click();
counter.click();
counter.click();
// console.log(counter.getCount());

class Hello {
  constructor(age) {
    this._age = age;
  }
  get age() {
    return this._age;
  }
}
const newUs = new Hello(25);
newUs.age = 30;
console.log(newUs.age);
// Функция User принимает два аргумента: name, age. Пример без инкапсуляции где мы можем добраться до свойств объекта
function User(name, age) {
  // Создали два новых объекта и присвоили им свойства
  this.name = name;
  this.age = age;
  // Функция say будет выводить в консоль определенную информацию
  this.say = function () {
    console.log(`Имя пользователя: ${this.name}, Возраст: ${this.age}`);
  };
}
// Создадим нового пользователя
const misha = new User("Misha", 25);
Получаем доступ к свойствам нового пользователя
console.log(misha.name);
console.log(misha.age);

misha1.userName = "Oskar"; // меняем имя
misha1.userAge = 32; // меняем возраст

Метод say() покажет какие значения есть у объекта на данный момент.
misha1.say();

Абстракция это способ создания простой модели, которая содержит только важные свойства с точки зрения контекства приложения. Иными словами это способ скрыть от пользователя детали реализации и показать пользователям лишь функциональность.
Мы не можем создать экземпляр абстрактного класса

Все программмное обеспечение это абстракция, скрывающая всю тяжелую работу и бездумные детали
Декомпозиция это процесс абстракции

Полиморфизм
Идея заключается в том чтобы вызывать один и тот же метод для разных объектов, и при этом каждый метод реагирует по своему
Для этого полиморфизм использует наследование

Это способность объекта в процессе своего выполнения ссылаться на экземпляры собственного класса или любого класса-потомка. Классы-потомки могут переопределять метод.
class Human {
  constructor(name) {
    this.name = name;
  }
  say() {
    return `hello my name is ${this.name} i like travelling`;
  }
}

class Man extends Human {
  constructor(name) {
    super(name);
  }
}
class Coder extends Human {
  constructor(name) {
    super(name);
  }
  say() {
    return `hello my name is ${this.name} i like coding`;
  }
}
const coder = new Coder("vlad");
const guy = new Human("guy");
console.log(coder.say());
console.log(guy.say());

Когда функция производит вложенный вызов, происходит следующее:
Выполнение текущей функции приостанавливается.
Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.

Классы JavaScript, представленные в ECMAScript 2015, в основном являются синтаксическим сахаром над существующим наследованием на основе прототипов JavaScript. Синтаксис класса не вводит новую объектно-ориентированную модель наследования в JavaScript.

Super in JS
Используется для вызова конструктора родителя
Super.<methodName> для вызова метода родителя
Классическое наследование класса с super
class fish {
  constructor(habitat, length) {
    this.habitat = habitat;
    this.length = length;
  }
}
class trout extends fish {
  constructor(habitat, length, variety) {
    super(habitat, length);
    this.variety = variety;
  }
}
Так можно делать и результат будет тот же что и выше  только в классе fish (habitat, variety = undefined)
class trout extends fish {
  constructor(habitat, length, variety) {
    super();
    this.habitat = habitat;
    this.length = length;
    this.variety = variety;
  }
}
Вызов родительского метода внутри функции дочернего
class fish {
  renderProperties(element) {
    element.innerHTML = JSON.stringify(this);
  }
}
class trout extends fish {
  renderPropertiesWithSuper(element) {
    element.className = "green";
    super.renderProperties(element);
  }
}

* Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса.
* Статические свойства и методы наследуются

Для сокрытия внутреннего интерфейса мы используем защищённые или приватные свойства:
Защищённые поля имеют префикс _. Это хорошо известное соглашение, не поддерживаемое на уровне языка. Программисты должны обращаться к полю, начинающемуся с _, только из его класса и классов, унаследованных от него.
Приватные поля имеют префикс #. JavaScript гарантирует, что мы можем получить доступ к таким полям только внутри класса.

* Проверка класса obj instanceOf Class

* Свойства-аксессоры представлены методами: «геттер» – для чтения и «сеттер» – для записи. При литеральном объявлении объекта они обозначаются get и set:
let obj = {
  get propName() {
    // геттер, срабатывает при чтении obj.propName
  },

  set propName(value) {
    // сеттер, срабатывает при записи obj.propName = value
  }
};Геттер срабатывает, когда obj.propName читается, сеттер – когда значение присваивается